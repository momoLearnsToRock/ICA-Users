const debug = require('debug')('app:helpers');
const sql = require('mssql');
const ResponseDTO = require('../DTO/responseDTO');
const config = require('../config/sql');

const Field = class {
  constructor(name, type) {
    this.name = name;
    this.type = type;
  }
};

const Table = class {
  constructor({ tableName, fields, autoGeneratedPrimeryKey }) {
    // this.tableName = tableName;
    // this.fields = fields;
    // this.autoGeneratedPrimeryKey = autoGeneratedPrimeryKey;
    if (!(fields instanceof Array)) {
      debug({ message: 'fields should be an array of objects of type fields' });
    }
    this.tableName = tableName;
    fields.forEach((f, index) => {
      if (!(fields[index] instanceof Field)) {
        debug({ message: 'fields should be an array of objects of type fields' });
      }
    });
    this.fields = fields;
    this.autoGeneratedPrimeryKey = autoGeneratedPrimeryKey;
  }

  getFieldNames(includeId) {
    let fieldsString = '';
    this.fields.forEach((item, index) => {
      if (includeId || item.name.toLowerCase() !== 'id') {
        fieldsString += item.name;
        if (index !== this.fields.length - 1) {
          fieldsString += ', ';
        }
      }
    });
    return fieldsString;
  }
};

const SQLTable = class extends Table {
  constructor({ tableName, fields, autoGeneratedPrimeryKey, connectionPool }) {
    super({ tableName, fields, autoGeneratedPrimeryKey });
    this.singleQuotedTypes = ['string', 'datetime', 'guid', 'unique identifier'];
    this.connectionPool = connectionPool;
  }

  createInsertIntoStatement(includeId, jsonBody, sqlReq) {
    const fields = this.getFieldNames(includeId);
    const values = [];
    this.fields.forEach((item, index) => {
      if (includeId || item.name.toLowerCase() !== 'id') {
        if (item.name === 'ModifiedOn') {
          values.push('GETDATE()');
        } else {
          values.push(`@${item.name}`);
          sqlReq.input(`${item.name}`, jsonBody[item.name]);
        }
      }
    });
    return `INSERT INTO ${this.tableName} (${fields}) VALUES (${values.join(', ')})`;
  }

  createDeleteStatement(id, sqlReq) {
    sqlReq.input('id', id);
    return `DELETE FROM ${this.tableName} WHERE Id = @id`; // please note that this would even work with the single quotes even for bigint
  }

  createUpdateStatement(includeId, jsonBody, id, sqlReq) {
    let setValuesArray = [];
    this.fields.forEach((item) => {
      if (typeof jsonBody[item.name] !== 'undefined') {
        if ((includeId || item.name.toLowerCase() !== 'id') && item.name !== 'ModifiedOn') {
          setValuesArray.push(` ${item.name} = @${item.name}`);
          sqlReq.input(`${item.name}`, jsonBody[item.name]);
        }
      }
    });
    const query =
      `UPDATE ${this.tableName}
      SET ModifiedOn = GETDATE(), ${setValuesArray.join(', ')} 
      WHERE Id = '${id}'`;
    debug(query);
    return query;
  }

  async getAll() {
    let result = null;
    try {
      const thisTableName = this.tableName;
      const pool = await new sql.ConnectionPool(config);
      const conny = await pool.connect();
      const requ = new sql.Request(pool);
      result = await requ.query(`select * from ${thisTableName}`);// where id = ${value}`
      debug(result);
      conny.close();
      return new ResponseDTO('', result);
    } catch (err) {
      debug(err);
      // sql.close();
      return new ResponseDTO('error', result);
    }
  }

  getAllPromise() {
    return new Promise((resolve, reject) => {
      let result = null;
      try {
        const thisTableName = this.tableName;
        const pool = new sql.ConnectionPool(config);
        const conny = pool.connect().then((conny) => {
          const requ = new sql.Request(conny);
          result = requ.query(`select * from ${thisTableName}`).then((result) => {
            debug(result);
            conny.close();
            resolve(new ResponseDTO('', result));
          }, (err) => {
            debug(err);
          });
        });
      } catch (err) {
        debug(err);
        // sql.close();
        reject(new ResponseDTO('error', result));
      }
    });
  }

  getAllPromisePool() {
    return new Promise((resolve, reject) => {
      let result = null;
      try {
        const thisTableName = this.tableName;
        const pool = new sql.ConnectionPool(config, (err) => {
          if (err) {
            debug(err);
          }
          // const conny = pool.connect().then((conny) => {
          const requ = new sql.Request(pool);
          result = requ.query(`select * from ${thisTableName}`).then((result) => {
            debug(result);
            resolve(new ResponseDTO('', result));
          }, (err) => {
            debug(err);
          });
          // });
        });
      } catch (err) {
        debug(err);
        // sql.close();
        reject(new ResponseDTO('error', result));
      }
    });
  }

  getAllPromiseSharedPool() {
    return new Promise((resolve, reject) => {
      let result = null;
      try {
        const thisTableName = this.tableName;
        // const pool = new sql.ConnectionPool(config, (err) => {
        //   if (err) {
        //     debug(err);
        //   }

        // const conny = pool.connect().then((conny) => {
        const requ = new sql.Request(this.connectionPool);
        result = requ.query(`select * from ${thisTableName}`).then((result) => {
          debug(result);
          resolve(new ResponseDTO('', result));
        }, (err) => {
          debug(err);
        });
        // });
        // });
      } catch (err) {
        debug(err);
        // sql.close();
        reject(new ResponseDTO('error', result));
      }
    });
  }

  async getAllPromiseSharedPoolAsync() {
    // return new Promise((resolve, reject) => {
    let result = null;
    try {
      const thisTableName = this.tableName;
      // const pool = new sql.ConnectionPool(config, (err) => {
      //   if (err) {
      //     debug(err);
      //   }

      // const conny = pool.connect().then((conny) => {
      const requ = new sql.Request(this.connectionPool);
      result = await requ.query(`select * from ${thisTableName}`);
      debug(result);
      return (new ResponseDTO('', result));
      // });
      // });
    } catch (err) {
      debug(err);
      // sql.close();
      return (new ResponseDTO('error', result));
    }
    // });
  }

};

module.exports = {
  Field,
  Table,
  SQLTable,
};
