const debug = require('debug')('app:helpers');
const sql = require('mssql');
const ResponseDTO = require('../DTO/responseDTO');
const config = require('../config/sql');

const Field = class {
  constructor(name, type) {
    this.name = name;
    this.type = type;
  }
};

const Table = class {
  constructor({ tableName, fields, autoGeneratedPrimeryKey }) {
    // this.tableName = tableName;
    // this.fields = fields;
    // this.autoGeneratedPrimeryKey = autoGeneratedPrimeryKey;
    if (!(fields instanceof Array)) {
      debug({ message: 'fields should be an array of objects of type fields' });
    }
    this.tableName = tableName;
    fields.forEach((f, index) => {
      if (!(fields[index] instanceof Field)) {
        debug({ message: 'fields should be an array of objects of type fields' });
      }
    });
    this.fields = fields;
    this.autoGeneratedPrimeryKey = autoGeneratedPrimeryKey;
  }

  getFieldNames(includeId) {
    let fieldsString = '';
    this.fields.forEach((item, index) => {
      if (includeId || item.name.toLowerCase() !== 'id') {
        fieldsString += item.name;
        if (index !== this.fields.length - 1) {
          fieldsString += ', ';
        }
      }
    });
    return fieldsString;
  }
};

const SQLTable = class extends Table {
  constructor({ tableName, fields, autoGeneratedPrimeryKey, connectionPool }) {
    super({ tableName, fields, autoGeneratedPrimeryKey });
    this.singleQuotedTypes = ['string', 'datetime', 'guid', 'unique identifier'];
    this.connectionPool = connectionPool;
  }

  createInsertIntoStatement(includeId, jsonBody, sqlReq) {
    const fields = this.getFieldNames(includeId);
    const values = [];
    this.fields.forEach((item, index) => {
      if (includeId || item.name.toLowerCase() !== 'id') {
        if (item.name === 'ModifiedOn') {
          values.push('GETDATE()');
        } else {
          values.push(`@${item.name}`);
          sqlReq.input(`${item.name}`, jsonBody[item.name]);
        }
      }
    });
    return `INSERT INTO ${this.tableName} (${fields}) VALUES (${values.join(', ')})`;
  }

  createDeleteStatement(id, sqlReq) {
    sqlReq.input('id', id);
    return `DELETE FROM ${this.tableName} WHERE Id = @id`; // please note that this would even work with the single quotes even for bigint
  }

  createUpdateStatement(includeId, jsonBody, id, sqlReq) {
    let setValuesArray = [];
    this.fields.forEach((item) => {
      if (typeof jsonBody[item.name] !== 'undefined') {
        if ((includeId || item.name.toLowerCase() !== 'id') && item.name !== 'ModifiedOn') {
          setValuesArray.push(` ${item.name} = @${item.name}`);
          sqlReq.input(`${item.name}`, jsonBody[item.name]);
        }
      }
    });
    const query =
      `UPDATE ${this.tableName}
      SET ModifiedOn = GETDATE(), ${setValuesArray.join(', ')} 
      WHERE Id = '${id}'`;
    debug(query);
    return query;
  }

  async getAll() {
    let result = null;
    try {
      const thisTableName = this.tableName;
      const pool = await new sql.ConnectionPool(config);
      const conny = await pool.connect();
      const requ = new sql.Request(pool);
      result = await requ.query(`select * from ${thisTableName}`);// where id = ${value}`
      debug(result);
      conny.close();
      return new ResponseDTO('', result);
    } catch (err) {
      debug(err);
      // sql.close();
      return new ResponseDTO('error', result);
    }
  }
};

module.exports = {
  Field,
  Table,
  SQLTable,
};
