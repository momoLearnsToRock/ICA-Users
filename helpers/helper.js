const debug = require('debug')('app:helpers');
const sql = require('mssql');
const ResponseDTO = require('../DTO/responseDTO');

const Field = class {
  constructor(name, type) {
    this.name = name;
    this.type = type;
  }
};

const Table = class {
  constructor({ tableName, fields, autoGeneratedPrimeryKey }) {
    if (!(fields instanceof Array)) {
      debug({ message: 'fields should be an array of objects of type fields' });
    }
    this.tableName = tableName;
    fields.forEach((f, index) => {
      if (!(fields[index] instanceof Field)) {
        debug({ message: 'fields should be an array of objects of type fields' });
      }
    });
    this.fields = fields;
    this.autoGeneratedPrimeryKey = autoGeneratedPrimeryKey;
  }

  // Todo: add possibility to put the names in brackets
  getFieldNames(includeId) {
    let fieldsString = '';
    this.fields.forEach((item, index) => {
      if (includeId || item.name.toLowerCase() !== 'id') {
        fieldsString += item.name;
        if (index !== this.fields.length - 1) {
          fieldsString += ', ';
        }
      }
    });
    return fieldsString;
  }
};

const SQLTable = class extends Table {
  constructor({ tableName, fields, autoGeneratedPrimeryKey, connectionPool }) {
    super({ tableName, fields, autoGeneratedPrimeryKey });
    this.singleQuotedTypes = ['string', 'datetime', 'guid', 'unique identifier'];
    this.connectionPool = connectionPool;
  }

  createInsertIntoStatement(includeId, jsonBody, sqlReq) {
    const fields = this.getFieldNames(includeId);
    const values = [];
    this.fields.forEach((item, index) => {
      if (includeId || item.name.toLowerCase() !== 'id') {
        if (item.name === 'ModifiedOn') {
          values.push('GETDATE()');
        } else {
          values.push(`@${item.name}`);
          sqlReq.input(`${item.name}`, jsonBody[item.name]);
        }
      }
    });
    const PKType = 'nvarchar(50)';// 'bigint'; // the sql datatype of the table's PK. Todo: get this value on instantiation of the tables in future
    const query =
      `DECLARE @_keys table([Id] ${PKType})

     INSERT INTO ${this.tableName} (${fields}) 
     OUTPUT inserted.Id INTO @_keys
     VALUES (${values.join(', ')})

     SELECT t.*
     FROM @_keys AS g 
     JOIN dbo.${this.tableName} AS t 
     ON g.Id = t.Id`;
    // note to developers: SCOPE_IDENTITY() would have been a good option but we have nvarchar ids. this method is a copy of what EF does
    return query;
  }

  createDeleteStatement(id, sqlReq) {
    sqlReq.input('id', id);
    return `DELETE FROM ${this.tableName} WHERE Id = @id`; // please note that this would even work with the single quotes even for bigint
  }

  createUpdateStatement(includeId, jsonBody, id, sqlReq) {
    let setValuesArray = [];
    this.fields.forEach((item) => {
      if (typeof jsonBody[item.name] !== 'undefined') {
        if ((includeId || item.name.toLowerCase() !== 'id') && item.name !== 'ModifiedOn') {
          setValuesArray.push(` ${item.name} = @${item.name}`);
          sqlReq.input(`${item.name}`, jsonBody[item.name]);
        }
      }
    });
    const query =
      `UPDATE ${this.tableName}
      SET ModifiedOn = GETDATE(), ${setValuesArray.join(', ')} 
      WHERE Id = '${id}'`;
    debug(query);
    return query;
  }

  async getAll() {
    let result = null;
    try {
      const requ = new sql.Request(this.connectionPool);
      result = await requ.query(`select * from ${this.tableName}`);
      debug(result);
      return (new ResponseDTO('error', result));
    } catch (err) {
      debug(err);
      return (new ResponseDTO('error', result));
    }
  }

  getByIdOld(id) {
    return new Promise((resolve, reject) => {
      try {
        const requ = new sql.Request(this.connectionPool);
        debug('select by id: ', `select * from ${this.tableName} where Id= @id`);
        requ.input('id', id);
        requ.query(`select * from ${this.tableName} where Id= @id`).then((result) => {
          debug('return of check for the same id', result);
          let item = null;
          if (!!result.recordset && result.recordset.length === 1) {
            item = result.recordset[0];
          }
          resolve(new ResponseDTO('', item));
        }, (err) => {
          debug(err);
          reject(new ResponseDTO(err, null));
        });
      } catch (err) {
        debug(err);
        reject(new ResponseDTO(err, null));
      }
    });
  }

  async getById(id) {
    try {
      const requ = new sql.Request(this.connectionPool);
      debug('select by id: ', `select * from ${this.tableName} where Id= @id`);
      requ.input('id', id);
      let result = await requ.query(`select * from ${this.tableName} where Id= @id`)
      debug('return of check for the same id', result);
      let item = null;
      if (!!result.recordset && result.recordset.length === 1) {
        item = result.recordset[0];
      }
      return new ResponseDTO('', item);
    } catch (err) {
      debug(err);
      return new ResponseDTO('error', err);
    }
  }

  // insert(jsonBody) {
  //   return new Promise((resolve, reject) => {
  //     let result = null;
  //     let msg = '';
  //     try {
  //       // await sql.connect(config);
  //       const requestIns = new sql.Request(this.connectionPool);
  //       result = await requestIns.query(this.createInsertIntoStatement(!this.autoGeneratedPrimeryKey, jsonBody, requestIns));
  //       if (result.rowsAffected != 0) {
  //         msg = 'item created';
  //       }
  //       debug('return of insert', result);
  //       return new ResponseDTO(msg, result);
  //     } catch (err) {
  //       debug(err);
  //       return new ResponseDTO('error', result);
  //     }  
  //   });
  // }

  async insert(jsonBody) {
    let result = null;
    let msg = '';
    try {
      // await sql.connect(config);
      const requ = new sql.Request(this.connectionPool);
      if (jsonBody.Id) {
        requ.input('Id', jsonBody.Id);
        result = await requ.query(`select * from ${this.tableName} where Id= @Id`);
        if (!!result.recordset && result.recordset.length !== 0) {
          return new ResponseDTO('error', 'an existing item already exists');
        }
      }
      const requestIns = new sql.Request(this.connectionPool);
      result = await requestIns.query(this.createInsertIntoStatement(!this.autoGeneratedPrimeryKey, jsonBody, requestIns));
      if (result.rowsAffected != 0) {
        msg = 'item created';
      }
      debug('return of insert', result);
      return new ResponseDTO(msg, result);
    } catch (err) {
      debug(err);
      return new ResponseDTO('error', result);
    }
  }
};

module.exports = {
  Field,
  Table,
  SQLTable,
};
